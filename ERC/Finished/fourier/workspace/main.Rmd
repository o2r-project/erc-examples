---
title: "Technical note: Fourier approach for estimating the thermal attributes of streams"
author: 
- affiliation: "Department of Aquatic Ecology, EAWAG, 8600 Duebendorf, Switzerland; Department of Civil Engineering, Tokyo Institute of Technology, 2-12-1 Ookayama, Meguro-ku, 152-0033 Tokyo, Japan; Institute of Integrative Biology, ETH-Zürich, 8092 Zürich, Switzerland"
  name: "Masahiro Ryo"
- affiliation: "Department of Aquatic Ecology, EAWAG, 8600 Duebendorf, Switzerland; Institute of Integrative Biology, ETH-Zürich, 8092 Zürich, Switzerland"
  name: "Marie Leys"
- affiliation: "Department of Aquatic Ecology, EAWAG, 8600 Duebendorf, Switzerland; Institute of Integrative Biology, ETH-Zürich, 8092 Zürich, Switzerland"
  name: "Christopher T. Robinson"
licenses:
  code: CC-BY-3.0
  data: CC-BY-3.0
  text: CC-BY-3.0
date: "24 August 2016"
output: html_document
doi: 10.5194/hess-20-3411-2016
abstract: "Temperature models that directly predict ecologically important thermal attributes across spatiotemporal scales are still poorly developed. This study developed an analytical method based on Fourier analysis to estimate seasonal and diel periodicities, as well as irregularities in stream temperature, at data-poor sites. The method extrapolates thermal attributes from highly resolved temperature data at a reference site to the data-poor sites on the assumption of spatial autocorrelation. We first quantified the thermal attributes of a glacier-fed stream in the Swiss Alps using 2 years of hourly recorded temperature. Our approach decomposed stream temperature into its average temperature of 3.8 ◦ C, a diel periodicity of 4.9 ◦ C, seasonal periodicity spanning 7.5 ◦ C, and the remaining irregularity (variance) with an average of 0.0 ◦ C but spanning 9.7 ◦ C. These attributes were used to estimate thermal characteristics at upstream sites where temperatures were measured monthly, and we found that a diel periodicity and the variance strongly contributed to the variability at the sites. We evaluated the performance of our predictive mechanism and found that our approach can reasonably estimate periodic components and extremes. We could also estimate the variability in irregularity, which cannot be represented by other techniques that assume a linear relationship in temperature variabilities between sites. The results confirm that spatially extrapolating thermal attributes based on Fourier analysis can predict thermal characteristics at a data-poor site. The R scripts used in this study are available in the Supplement."
---


Figure 2: Hourly time series temperature at the reference site decomposed using Fourier decomposition analysis...


```{r prep, echo=FALSE, cache=FALSE, results="hide", message=FALSE , warning=FALSE, comment=FALSE, warning=FALSE, out.width=700}
##########################################################################
#
#  Fast Fourier Transform of hourly time-series temperature data to 
#    1) detect key spectra which largely compose the variability
#    2) decompose it to mean, seasonal and diel cycles, and noise
#
# Input:   an hourly recorded temperature data (text file)
#           1st column for "Time" and 2nd column for "Temperature"
#           "example_data1.txt" is analyzed.
# parameter: threshold value for noise removal (threshold, ?C)
# Output: figure for summary and decomposed temperature as csv
#
#                    2016.07    Masahiro Ryo
#                         masahiroryo@gmail.com
#
#
##########################################################################

###############################################################
###     PREPARATION PART
###############################################################

#setwd("C:/")
data<-read.table("example_data1.txt",sep="\t", header=TRUE)
Time <-as.POSIXct(strptime(data$Time,format="%Y.%m.%d %H:%M"))
  # default format for time: YYYY.MM.DD HH:MM
  # e.g. 2013.05.17 23:00
N <- nrow(data)

##########################################################################
# FFT (Fast Fourier Transform) to capture seasonal and dial periodicity
###########################################################################
### Fourier Transform
FFT_Temperature <- fft(data$Temperature)/N  
FFT_max <- max(Mod(FFT_Temperature[2:(N/2)]))


### Extracting only key spectrum for modeling
 ################################################################
 # Tips: what should be interpreted?                            #
 #   What are the key seasonalities in data?                    #
 #    -> check the length of key periodic cycles (specs_day)    #
 #   How strong are they?                                       #
 #    -> check the absolute value of corresponding coefficient  #
 #       (abs(FFT_Temperature))                             #
 #   How much do they compose data variability?                 #
 #    -> check the correlation and visualized plot              #
 #       after modeling used only the key seasonalities         #
 ################################################################
### threshold selection #######################
threshold <- 0.2 # this can be measurement-specific ####
# Note: threshold can be arbitrary, try different values and visually evaluate from figures
# a recommendation is to set it firstly to the value of minimum unit of measurement  

### selecting spectra whose intensity is higher than the threshold
### assuming they dominantly constitute seasonal and diel cycles
FFT_Tmain <- which(Mod(FFT_Temperature) > threshold) 
specs <- 1/(FFT_Tmain/N)   # period lengths of spectra selected by the threshold (T=1/f) [hour]
nspecs <- length(specs)

FFT_seasonal <- FFT_Tmain[which(specs>30*24 & specs<367*24)] # extracting seasonal component
FFT_seasonal <- append(FFT_seasonal, FFT_Tmain[nspecs-which(is.element(FFT_Tmain,FFT_seasonal))+2])  # also corresponding ones
FFT_diel <- FFT_Tmain[which(specs>11 & specs<25)]              #  diel component
FFT_diel <- append(FFT_diel, FFT_Tmain[nspecs-which(is.element(FFT_Tmain,FFT_diel))+2])

### removing noises whose spectral intensity is lower than the threshold
FFT_Temperature_selected <- replace(FFT_Temperature,c(-FFT_Tmain),0)    
FFT_Temperature_seasonal <- replace(FFT_Temperature,c(-FFT_seasonal),0)
FFT_Temperature_diel     <- replace(FFT_Temperature,c(-FFT_diel),0)

### transforming from frequency field to time field
Temperature_selected  <- Re(fft(FFT_Temperature_selected, inverse=TRUE))  
Temperature_seasonal <- Re(fft(FFT_Temperature_seasonal, inverse=TRUE))
Temperature_diel     <- Re(fft(FFT_Temperature_diel,     inverse=TRUE))
ext.factor <- data$Temperature - abs(Temperature_selected) # noise (external factor)
# Note: Only Real part of the inversed FFT is needed in time series


### Plotting and comparing the FFT estimation and the observed data
par(mfrow=c(3,2))
par(mar=c(2,5,1,1))
plot(Mod(FFT_Temperature[1:(N/2)]), ylab="spectral intensity")
plot(Time, data$Temperature, type="l", col="black", ylab="Observed")
plot(Time, Temperature_selected, type="l", col="red", ylab="Mean + Seasonal + Diel" )
plot(Time, Temperature_seasonal, type="l", col="red", ylab="Seasonal")
plot(Time, Temperature_diel, type="l", col="red", ylab="Diel")
plot(Time, ext.factor, type="l",col="gray", ylab="external factor (noise)")

### exporting results as csv:
result <- data.frame(cbind(as.character(data$Time), data$Temperature, Temperature_selected,
                           Temperature_seasonal,Temperature_diel, ext.factor))
colnames(result) <- c("Time", "Observed", "Modeled", "Seasonal", "Diel", "Noise")
write.csv(result, "FFT_estimation_result.csv")
``` 

```{r, include=FALSE}
##########################################################################
#
#  Estimating hourly time-series temperature and thermal attributes at
#  a spot-measured site, using hourly time-series temperature data at 
#  another site (e.g. hydrological gauging station).
#
#  This code requires to run the R script "Fourier_1.R" beforehand
#  as this script uses some variables which are generated by the script. 
#
#  Input: an hourly recorded temperature data (text file)
#           1st column for "Time" and 2nd column for "Temperature"
#           "example_data2.txt" is analyzed.
#
# Output: figure for summary and decomposed temperature as csv
#
#                    2016.07    Masahiro Ryo
#                         masahiroryo@gmail.com
#
#
##########################################################################

###############################################################
###     PREPARATION PART
###############################################################
#setwd("C:/Users/Public/Documents/")

### to read a spot-measured data and couple with the time-series data
observed <- read.table("example_data2.txt",sep="\t", head=T)
observed[,1] <- as.POSIXct(strptime(observed[,1],format="%Y.%m.%d %H:%M"))
observed <- cbind(observed, data$Temperature[is.element(Time, observed[,1])], ext.factor[is.element(Time, observed[,1])])
colnames(observed) <- c("Time", "Obs", "ts", "noise")  


###################################################################
# To estimate parameters: b1, b2, b3, b4, b5
# see eq.7 in the paper
###################################################################
### To estimate parameters b1 and b5
b1 <- lm(observed$Obs~observed$ts)$"coefficients"[2]  # slope of linear regression
b5 <- lm(observed$Obs~observed$ts)$"coefficients"[1]  # intercept of linear regression

### To estimate parameters b2 and b3 by least squares method
min_mse <- 1.0e+5; b2 <- 0.0; b3 <- 0.0

for(b2.tmp in seq(0.01, 1.0, by = 0.01)){
  for(b3.tmp in seq(0.01, 1.0, by = 0.01)){
    FFT_corrected <- FFT_Temperature_selected
    ### average temperature is adjusted by the slope of linear regression
    FFT_corrected[1] <- b1*FFT_Temperature[1]

    ### seasonal
    FFT_corrected[FFT_seasonal] <- complex(re=b2.tmp*Re(FFT_corrected[FFT_seasonal]),
                                           im=b2.tmp*Im(FFT_corrected[FFT_seasonal]))
    ### diel
    FFT_corrected[FFT_diel] <- complex(re=b3.tmp*Re(FFT_corrected[FFT_diel]),
                                       im=b3.tmp*Im(FFT_corrected[FFT_diel]))

    Temperature_corrected <- Re(fft(FFT_corrected, inverse=TRUE))  # transforming from frequency to time
    Temperature_corrected <- data.frame(data$Time,Temperature_corrected)
    Z_dt  <- observed$Obs - Temperature_corrected[is.element(Time, observed[,1]),2]
    tmp_mse <- sum(lm(observed$noise~Z_dt)$residuals^2)
    if (tmp_mse < min_mse) {min_mse <- tmp_mse; b2 <- b2.tmp; b3 <- b3.tmp}
  }  
}

### update FFT_corrected with fitted parameters
FFT_corrected <- FFT_Temperature_selected
FFT_corrected[1] <- b1*FFT_Temperature[1]
FFT_corrected[FFT_seasonal] <- complex(re=b2*Re(FFT_corrected[FFT_seasonal]),
                                       im=b2*Im(FFT_corrected[FFT_seasonal]))
FFT_corrected[FFT_diel] <- complex(re=b3*Re(FFT_corrected[FFT_diel]),
                                   im=b3*Im(FFT_corrected[FFT_diel]))
Temperature_corrected <- Re(fft(FFT_corrected, inverse=TRUE))  # transforming from frequency to time
Temperature_corrected <- data.frame(data$Time,Temperature_corrected)


### To estimate parameters b4 by least squares method
min_mse2 <- 1.0e+5; b4 <- 0.0
for (b4.tmp in seq(0,1, by=0.01)){
  tmp <- Temperature_corrected
  tmp[,2] <- Temperature_corrected[,2] + b4.tmp*ext.factor
  tmp[which(tmp[,2]<0),2] <- tmp[which(tmp[,2]<0),2]  - b5
  tmp[which(tmp[,2]<0),2] <- 0
  Est <- tmp[is.element(Time, observed[,1]),2]
  tmp_mse2 <- sum(lm(observed$Obs~Est)$residuals^2)
  if (tmp_mse2 < min_mse2) {min_mse2 <- tmp_mse2; b4 <- b4.tmp}
}


### finalize estimation with fitted parameters
tmp[,2] <- Temperature_corrected[,2] + b4*ext.factor + b5 
tmp[which(tmp[,2]<0),2] <- tmp[which(tmp[,2]<0),2]  - b5
tmp[which(tmp[,2]<0),2] <- 0
Timeseries.estimated <- tmp
spot.fitted <- tmp[is.element(Time, observed[,1]),2]

### results
lm.result <- lm(observed$Obs~spot.fitted)
r2 <- summary(lm.result)$"r.squared"

plot(Timeseries.estimated[,2], type="l")
plot(observed$Obs, spot.fitted)  
parameter.estimated <- cbind(round(b1, digits = 2),b2,b3,b4,round(b5, digits = 2))
rownames(parameter.estimated)<- c("")

### exporting results as csv:
write.csv(Timeseries.estimated, "Extrapolation_result.csv")
parameter.estimated
r2 # r-squared between observed and estimated (fitting)
  
```

